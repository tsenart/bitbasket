<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>BitBasket</title>
  <link href="http://fonts.googleapis.com/css?family=Neucha" rel="stylesheet" type="text/css">
  <link href="css/bitbasket.css" rel="stylesheet" type="text/css">
  <script src="js/underscore.js" type="text/javascript"></script>
</head>
<body>
  <img id="bit" src="imgs/bit.png" title="All your base belongs to us.">
  <canvas id="basket">
    Your browser does not support the canvas tag.
  </canvas>
  <script type="text/javascript">
    var canvas = document.getElementById('basket');
    var socket = new WebSocket('ws://' + document.location.host);
    var ctx = canvas.getContext('2d');
    var step = 15;
    var offset = [0, 0];
    var speed = {38: [0, step, 0], 37: [step, 0, 0], 40: [0, -step, 0], 39: [-step, 0, 0]};
    var bits = [];
    var bitTexture = document.getElementById('bit');
    var uuid = '';
    
    function wipeCanvas() {
      canvas.width = document.body.clientWidth;
      canvas.height = window.innerHeight - 30;
    }
    
    function draw(e) {
      wipeCanvas();
      if(e && e.keyCode && _(speed).keys().map(function(m){return parseInt(m)}).indexOf(e.keyCode) > -1)
        speed[e.keyCode][2] = 1;
        
      _(bits).each(function(bit){
        _(speed).chain().select(function(i){ return i[2] == 1 }).each(function(sp){
          bit.coords.x += sp[0];
          bit.coords.y += sp[1];
        });
        ctx.drawImage(bitTexture, bit.coords.x - 25, bit.coords.y - 25);
      });
      _(speed).chain().select(function(i){ return i[2] == 1 }).each(function(sp){
        offset[0] += sp[0];
        offset[1] += sp[1];
      });
    }
    
    function cursorOnBit(e) {
      return _(bits).any(function(bit) {
        return e.x < bit.coords.x + 25  &&
               e.x > bit.coords.x - 25  &&
               e.y < bit.coords.y + 25  &&
               e.y > bit.coords.y - 25;
      });
    }
    
    function bitOnCursor(e) {
      return _(bits).filter(function(bit) {
        return e.x < bit.coords.x + 25  &&
               e.x > bit.coords.x - 25  &&
               e.y < bit.coords.y + 25  &&
               e.y > bit.coords.y - 25;
      });
    }
    
    socket.onmessage = function(data) {
      var msg = JSON.parse(data.data);
      if(msg.uuid && !msg.coords && !msg.del) uuid = msg.uuid;
      else {
        if(msg.coords && msg.uuid != uuid) {
          msg.coords.x += offset[0];
          msg.coords.y += offset[1];
          bits.push(msg);
        }
        if(msg.del)
          bits = _(bits).filter(function(b){ return b.uuid != msg.uuid });
      }
      draw();
    };
     
    function noop(e) {
      e.stopPropagation();
      e.preventDefault();
    }
        
    canvas.ondragenter = canvas.ondragover = canvas.ondragexit = noop;
    document.onkeydown = window.onresize = window.onload = draw;
    
    document.onkeyup = function(e) {
      if(_(speed).keys().map(function(m){return parseInt(m)}).indexOf(e.keyCode) > -1)
        speed[e.keyCode][2] = 0;
    };
    
    canvas.onmousemove = function(e) {
      if(cursorOnBit(e))
        document.body.style.cursor = 'pointer';
      else
        document.body.style.cursor = 'default';
    };
    
    canvas.onclick = function(e) {
      if(cursorOnBit(e)) {
        var bit = bitOnCursor(e)[0];
        document.location = document.location.host + '/' + encodeURIComponent(uuid) + '/' + encodeURIComponent(bit.file.name);
      }
    };
    
    canvas.ondrop = function(e) {
      noop.apply(this, arguments);
      bits.push({uuid: uuid, file: e.dataTransfer.files[0], coords: {x: e.x - 25, y: e.y - 25}});
      ctx.drawImage(bitTexture, _(bits).last().coords.x - 25, _(bits).last().coords.y - 25);
      
      var reader = new FileReader();
      reader.onloadend = function(e) {
        socket.send(JSON.stringify({
          uuid: uuid,
          file: {
            name: _(bits).last().file.name,
            size: _(bits).last().file.size,
            data: btoa(e.target.result)
          },
          coords: {
            x: _(bits).last().coords.x - offset[0],
            y: _(bits).last().coords.y - offset[1]
          }
        }));
      };
      reader.readAsBinaryString(_(bits).last().file);
    };
    
    // window.onbeforeunload = function(e) {
    //      noop.apply(this, arguments);
    //      var bitcount = _(bits).filter(function(b){ return b.uuid == uuid }).length;
    //      if(bitcount > 0) {
    //        return "If you exit you'll stop sharing " + bitcount + " files. Are you sure?"
    //      }
    //    }
        
  </script>
</body>
</html>